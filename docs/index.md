{% include ddc-abbreviations.md %}

## Overview

{% include assignment-info.md %}

A former member of your development team was working on a random password generator web service when they left, and it's now fallen to you to pick up the project.

What you have are the specifications (below), and the code the former team member left behind. It seems to be mostly complete---at least for the basic goals (and it looks like the separation-of-concerns portion of the stretch goals is reflected in the code)---but the code is not in a compilable state. 

You also remember from scrum stand-ups that the former team member got the code to compile a few times, but the application crashed as it was starting, indicating unsatisfied dependencies.

Of course, you know that once the code is running, you'll have to test it---using the HTTP client facilities in IntelliJ IDEA, and maybe even some quick-and-dirty work with a web browser. Given the state it was left in, and knowing that the service didn't even run, you suspect there might be some logical problems in the code, as well. That is, even when you get it running, and can send it requests, there's guarantee that it's building passwords that meet the specifications.

Your task then is to read the specifications carefully---starting with the basic goal, but also the stretch goals as well---and then try to get at least the basic goal functionality working. Then, if you have enough time, you'll think about some of the stretch goals.

## Basic goal

Using Spring Boot, you must write a web service that returns a password generated randomly from a specified set of characters.

This should be a very simple service, with a single controller class mapped to the server relative URL `/api/password`, handling the `GET` HTTP method, and returning a JSON response. No persistence is required---though you may choose to add a service class to handle the business logic (i.e. the actual generation of passwords).

### Implementation

#### Specifications

For full credit, the following elements must be implemented:

1. The service endpoint must be accessible at a server-relative path of `/api/password`.

2. The implemented endpoint must handle HTTP `GET` requests.

3. The service must support 2 query string parameters:

    * `String pool`

        The set of characters from which the random password should be selected. (Required)

    * `int length`

        The length (in number of characters) of the password to be generated. (Optional, with a default value of 12.)

4. The service must be implemented as described above, and must be testable manually using a browser, HTTP REST client tool, etc.

5. The random number generator used must be of cryptographic quality. (Note: The `java.util.Random` class does not satisfy this condition, but there is at least one other class---a subclass of `Random`---in the Java standard library that does.)

**Important**: This project is **not** the same as our Diceware application. The main difference is that this service must generate a random string of characters chosen from a pool of characters, while Diceware generates a passphrase by selecting random _words_ from a word list. After generation, Diceware returns a `String[]` or *`List`*`<String>`
 
In short, do not assume that you can simply use the Diceware code for this project. 

#### Examples

* `GET /api/password?pool=abcdefghijklmnopqrstuvwxyz` should return a password of length 12, generated by randomly selecting (with replacement---i.e., inclusion of any given character multiple times _is_ allowed) from the set of lowercase Latin letters. 

* `GET /api/password?pool=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&length=16` should return a password of length 16, generated by randomly selecting from the set containing the uppercase Latin letters and the digits 0 through 9.

#### Tips

1. The `pom.xml` file of the repository already includes all the dependencies you should need.

2. **Important**: Be sure to review the contents of `src/main/resources/application.yaml` for the default context path and port configuration of the service. (We don't recommend changing these without a compelling reason to do so.)

3. Query string parameters are indicated in a Spring MVC controller method by the use of the `@RequestParam` annotation on a method parameter.

4. An optional query string parameter is indicated by the `required=false` element in the `@RequestParam` annotation.

5. A default value may be set for a query string parameter by assigning a value to the `defaultValue` element in the `@RequestParam` annotation.

## Stretch goals

### Implementation

Modify your implementation to include one or more of the items specified below. Note the sum of points available for these items is more than the maximum points for stretch goals shown in the [overview](#overview); try to focus on the subset of stretch goal items you feel most confident addressing.

#### Specifications

1. Prior to generating the password, filter `pool` so that it contains no duplicate characters. [5 points]

2. Make the `pool` parameter optional, with a default value of the set of characters in the Unicode range `\u0021`--`\u007E` (inclusive). This range contains the upper- and lower-case Latin letters, the digits 0--9, and the punctuation characters of the Basic Latin Unicode block. [5 points] 

3. Add (and handle) a `String exclude` query string parameter, which can be used to exclude the specified characters from the pool (regardless of whether the latter is explicitly provided in the `pool` parameter, or takes the default value). [5 points]
    
4. Add (and handle) an optional `boolean excludeAmbiguous` query string parameter, with a default value of `false`. When a `true` value is passed on invocation, the upper-case `'O'` and lower-case `'l'` characters must be excluded from the pool. [5 points] 

5. Add simple input validation, so that a negative value of `length` or an empty `pool` results in an HTTP 400 (bad request). [5 points]

6. In combination with the above items, add slightly more advanced  input validation, so that if nothing remains in the pool after removing any duplicates, exclusions, and ambiguous characters (as specified---or not---by the `pool` parameter or the default pool, the `exclude` parameter, and the `excludeAmbigous` parameter), an HTTP 400 (bad request) is returned to the client. [5 points]

7. Separate the concerns. Specifically, perform the actual password generation not in the controller class, but in a service class that implements an interface in which the relevant generation method (or methods) is declared. The interface must be declared as a dependency of the controller using constructor injection, and the concrete implementation must be annotated with the Spring `@Service` annotation. [5 points]

#### Tips

1. The `pom.xml` file of the repository already includes all the dependencies you should need, including those required for basic validation of HTTP query string parameters.

2. For a good overview of query string parameter validation, see ["Validating RequestParams and PathVariables in Spring"](https://www.baeldung.com/spring-validate-requestparam-pathvariable). For a list of basic validation annotations, see ["Java Bean Validation Basics"](https://www.baeldung.com/javax-validation).)

3. An exception type can be mapped to an HTTP response status by combining the `@ExceptionHandler` and `@ResponseStatus` annotations on a method in a controller class, or in a class annotated with 
 `@RestControllerAdvice`. In simple cases, the annotated method need not do any processing; the simple mapping of annotations is often sufficient. 

    For example, the following method maps `IllegalArgumentException` to an HTTP response status of 400 (bad request), with a message of "bad request parameter". 

    ```java
    @ExceptionHandler(IllegalArgumentException.class)
    @ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "Bad request parameter")
    public void badRequest() {
    }
    ```

    If included in a controller class, the mapping will be in effect for all controller methods in the class; if included in a class annotated with `@RestControllerAdvice`, located within the base backage of the application (typically in a subpackage of that base), the mapping will be in effect for all controller methods in the application.

4. Remember that a class must be annotated with one of the Spring component annotations (e.g. `@Component`, `@Configuration`, `@Service`) to participate in dependency injection. 

5. A method annotated with `@Bean` may satisfy a declared dependency on the method's return type. 

{% comment -%}

### Unit tests

For full credit, you must write your own unit tests (and add the necessary dependencies to your `pom.xml`), to verify the following:

* The length of the string returned is as specified in the `length` parameter, for a reasonable set of non-negative `length` values.

* The string returned contains no characters not present in `pool`. Since the result is randomly generated, this test must be repeated a reasonable number of times. (Hint: See the `@RepeatedTest` annotation of JUnit5.)

* For this exam, you may write your tests to invoke your controller methods or service methods directly, rather than over HTTP. In either case, remember to use Spring dependency injection to create any necessary instances of your controller and/or service class.

{%- endcomment %}
